<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Glukit</title>
    <link rel="stylesheet" href="css/foundation.css" />
    <script src="js/vendor/custom.modernizr.js"></script>
      <link type="text/css" rel="stylesheet" href="css/graph.css">
      <link type="text/css" rel="stylesheet" href="css/detail.css">
      <link type="text/css" rel="stylesheet" href="css/main.css">
    	<script src="js/d3.v3.js"></script>
    	<script src="js/jquery-2.0.0.min.js"></script>
      <script type="text/javascript" src="/_ah/channel/jsapi"></script>
      <script src="js/main.js"></script>      
  </head>
  <body class="dataPage">

<div class="sticky">
  <nav class="top-bar dataPage-topbar mainDataPage">
    <ul class="title-area">
    <!-- Title Area -->
      <li class="name">
      <h1><a href="index.html"><img src="images/glukit.png" id="droplet"></a></h1>
      </li>
    <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
      <li class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></li>
  </ul>
  <div class="fixed"></div>
  <section class="top-bar-section">
    <!-- Left Nav Section
    <ul class="left hackwhite">
    </ul>
    -->
    <!-- Right Nav Section -->
    <ul class="right">
     <li class="divider"></li>
      <li class="active navlink"><a href="#">How you're doing</a></li>
      <li class="divider "></li>
      <li class="active navlink"><a href="#">Compare</a></li>
      <li class="divider"></li>
      <li class="active navlink"><a href="#">Explore</a></li>
      <li class="divider"></li>
      <li class="divider hide-for-small"></li>
      <li class="has-form">
        <a class="button" href="index.html" style="color:white !important">Sign out</a>
      </li>
      <!-- <li class="active hackwhite has-dropdown"><img src="img/settings-cog.png"></li> -->
      <li class="divider"></li>
    </ul>
  </section>
</div>
</nav>
</div>

<!-- Overlay if user hasn't imported data yet. NOT YET STYLED - NEED TO FIX! -->
  <div id="overlay" class="hidden">
    <div class="row">
      <div class="large-16 columns">
        <div class="large-3 large-offset-1 columns"> <img src="images/surprisedglukit.png" id="nodataGlukit"></img></div>
        <div class="large-10 columns"><h2>Uh oh! Looks like you havent uploaded any data yet. Let's get you up and running.</h2></div>
      </div>
    </div>
  </div>

<div class="row belowHeader" style="overflow:hidden; padding-top:4px">
    <div class="large-16 columns">
      <div class="row">
        <div class="large-16 columns">
          <h3 class="datepicker" style="color:#888"><img src="images/back-arrow.png">           Friday, July 26th 2013</h3>
          <!-- <p style="float:right; color: #404040; padding-top:6px">Welcome, Alex!</p> -->
        </div>
      </div>

      <!-- Should be generating this dynamically - not DRY as is. -->
      <div class="row dashboard">
        <div class="large-4 columns">
          <div class="slab">
            <div class="insights glukitScore"></div>
            <h5>Glukit score</h5>
          </div>
        </div>
        <div class="large-4 columns">
          <div class="slab">
            <div class="insights dailyAverage"></div>
            <h5>Daily average</h5>
          </div>
        </div>
        <div class="large-4 columns">
          <div class="slab">
            <div class="insights dailyHigh"></div>
            <h5>Daily high</h5>
          </div>
        </div>
        <div class="large-4 columns">
          <div class="slab">
            <div class="insights dailyLow"></div>
            <h5>Daily low</h5>
          </div>
        </div>
      </div>

      <hr id="features">
      <div class="row">
        <div class="large-16 columns">
          <div class="slab graph">
            <div id="chart_container">            
              <div id="y_axis"></div>
              <div id="chart" style="clear: both"></div>
              <div id="hoverbox" class="hoverbox"></div>                        
            </div>
            <div id="slider"></div>            
          </div>
          </div>
        </div>
      </div>
      <div class="row">
        <div class="footer">
          <div class="large-16 columns" style="height:30px">
          </div>
        </div>
      </div>
    </div>
  </div>
<script>
    var TARGET_RANGE_LOWER_BOUND = 63;
    var TARGET_RANGE_UPPER_BOUND = 127;
    // Default to 5 hours 
    var SNAP_DISTANCE_IN_MILLIS = 5 * 2700000;

    var RANGES = {
      HIGH: "HIGH",
      NORMAL: "NORMAL",
      LOW: "LOW"
    }

    function showDataBrowser() {
    var chartNode = document.getElementById("chart");
    chartNode.innerHTML = '';

    var margin = {top: 10, right: 10, bottom: 100, left: 40},
    margin2 = {top: 430, right: 10, bottom: 20, left: 40},
    width = 800 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom,
    viewfinderHeight = 500 - margin2.top - margin2.bottom;

    // Our dates are milliseconds since epoch so that parse function
    // just instantiates a new Date from it.
    var parseDate = function(d) { return new Date(d) };

    // Define the scales
    var x = d3.time.scale().range([0, width]),
    x2 = d3.time.scale().range([0, width]),
    y = d3.scale.linear().range([height, 0]),
    y2 = d3.scale.linear().range([viewfinderHeight, 0]);

    // Define the axes
    var xAxis = d3.svg.axis().scale(x).orient("bottom"),
    xAxis2 = d3.svg.axis().scale(x2).orient("bottom"),
    yAxis = d3.svg.axis().scale(y).orient("left");

    var glucoseLine = d3.svg.line()
      .x(function(d) { return x(d.date); })
      .y(function(d) { return y(d.y); });

    var viewfinderLine = d3.svg.line()
      .x(function(d) { return x2(d.date); })
      .y(function(d) { return y2(d.y); });

    // Find a way to change those as the viewfinder moves
    var userEventArc = d3.svg.arc()
      .innerRadius(2)
      .outerRadius(7)      
      .startAngle(function(d)
           {
            switch (d.type) {
              case "full":                 
                return 0 * Math.PI;
              case "left":                 
                return 1 * Math.PI;
              case "right":                
                return 1 * Math.PI;
             }                      
           
             })
      .endAngle(function(d)
           {
           switch (d.type) {
            case "full": 
              return 2 * Math.PI;
            case "left": 
              return 2 * Math.PI;
            case "right":
              return 0 * Math.PI;
          } });

   var svg = d3.select("#chart").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom);
      
    // That should be the lower bound of the times displayed on the graph
    // driven by the "self" data
    d3.json("/{{.PathPrefix}}data", function(error, data) {
      glucoseReads = data.data[0].data;
      userEvents = data.data[1].data;

      timeRangeLowerBound = glucoseReads[0].x;
      glucoseReads.forEach(function(d) {
        d.date = parseDate(d.x * 1000);
      });
    
      var highestOnChart = d3.max(glucoseReads, function(d) { return d.y; }) + 100;
      x.domain(d3.extent(glucoseReads.map(function(d) { return d.date; })));
      y.domain([0, highestOnChart]);
      x2.domain(x.domain());
      y2.domain(y.domain());

      var focus = svg.append("g")      
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      var context = svg.append("g")
      .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");
     
      focus.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

      focus.append("rect")
            .attr("class", "target_range")
            .attr("clip-path", "url(#rangeClip)")
            .attr("width", width)
            .attr("height", height);

      focus.append("g")
            .attr("class", "y axis")
            .call(yAxis);

      var focusLine = d3.svg.line()
                    .x(function(d) { return x(d.x); })
                    .y(function(d) { return d.y; })
                    .interpolate('linear');

      var focusCoordinates = [];
      focusCoordinates[0] = new Object();
      focusCoordinates[1] = new Object();
      
      focusCoordinates[0].x = 0;
      focusCoordinates[0].y = 0;
      focusCoordinates[1].x = 0;
      focusCoordinates[1].y = height;

      var focusLineElement = focus.append("path")
            .attr("id", "focusLine")
            .attr("class", "focusLine")
            .attr("clip-path", "url(#clip)")
            .datum(focusCoordinates)
            .attr("d", focusLine);

      var hoverbox = d3.select("#hoverbox");   
      var chartContainerElement = d3.select("#chart_container")[0][0];   

      context.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + viewfinderHeight + ")")
            .call(xAxis2);

      addTargetRangeClip(svg, width, height, "rangeClip", TARGET_RANGE_LOWER_BOUND, TARGET_RANGE_UPPER_BOUND, highestOnChart, y);

      addToGraph(focus, "self", context, glucoseReads, y, glucoseLine, viewfinderLine);    

      // Trying out the grouping, it doesn't actually use any of this
      userEvents.forEach(function(d) {
        d.date = parseDate(d.x * 1000);
      });
      var userEventGroups = groupEvents(userEvents, 60);

      // The clip path needs to be set on the group of userEvents and NOT on the individual arcs because otherwise,
      // the arcs will get clipped before the transformation and we're never going to be able to get a full circle or 
      // semi-circle
      userEventsSvg = focus.append("g").attr("class", "userEvents").attr("clip-path", "url(#clip)");
      for (var i = 0; i < userEventGroups.length; i++) {
        markers = generateEventMarkers(userEventGroups[i]);
        for (var j = 0; j < markers.length; j++) {          
          userEventsSvg.append("path")
           .attr("class", "event " + markers[j].tag)
           .attr("transform", "translate(" + x(markers[j].date) + "," + y(markers[j].y) + ")")                      
           .datum(markers[j])           
           .attr("d", userEventArc);      
         }        
      }      

      function brushed() {      
        x.domain(brush.empty() ? x2.domain() : brush.extent());        
        focus.selectAll("path.self").attr("d", glucoseLine);
        focus.selectAll("path.steadySailor").attr("d", glucoseLine);         
        focus.selectAll("path.event").attr("transform", function(d) { return "translate(" + x(d.date) + "," + y(d.y) + ")"; });
        focus.select(".x.axis").call(xAxis);        
      }

      // snap to days if close enough
      function snapBrush() {      
        if (!d3.event.sourceEvent) return; // only transition after input
        extent = brush.extent();
        viewfinderUpperLimit = extent[1];

        // We iterate from most recent since we assume that most users will look at that data more often        
        for (var i = 0; i < snapGuides.length; i++) {
           snap = snapGuides[i]
           
           diffInMillis = Math.abs(viewfinderUpperLimit - snap);
           if (diffInMillis <= SNAP_DISTANCE_IN_MILLIS) {              
              snapExtent = getDayRangeFromUpperBound(snap.getTime() / 1000);              
              d3.select(this).transition()
                .call(brush.extent(snapExtent))
                .call(brush.event)
                .duration(500)
                .ease("elastic", 15, .25);  
              return;
           }           
        }
      }

      mostRecentReadTimeInSeconds = glucoseReads[glucoseReads.length - 1].x;      
      brushRange = getDayRangeFromUpperBound(mostRecentReadTimeInSeconds);

      // 1 snap every day for 7 days
      var snapGuides = getDateSnapGuides(mostRecentReadTimeInSeconds, 86400, 7); 
      
      var brush = d3.svg.brush()
         .x(x2)        
         .extent(brushRange)
         .on("brush", brushed)
         .on("brushend", snapBrush);
     
      brushElement = context.append("g");
      brushElement.attr("class", "x brush")
          .call(brush)
        .selectAll("rect")
          .attr("y", -6)
          .attr("height", viewfinderHeight + 7);
      
      // Remove resize handles because we don't want to allow resizing. The brush is fixed to the length of one day
      brushElement.selectAll(".resize").remove();
      // Disable cross-hair cursor to avoid user overriding the brush completely
      brushElement.selectAll(".background").style("cursor", "auto");;
      
      // Call a first brushed to view the last day only 
      brushed();

      // Add steady sailor data
      d3.json("/{{.PathPrefix}}steadySailor", function(error, data) {
        rawSteadySailor = data.data[0].data;
        
        steadySailor = rawSteadySailor
        if (steadySailor.length > 0) {   
          offset = steadySailor[0].x - timeRangeLowerBound;              
          steadySailor.forEach(function(element) {
            element.x = element.x - offset;          
          });
        }

        steadySailor.forEach(function(d) {    
          d.date = parseDate(d.x * 1000);     
        });

      addToGraph(focus, "steadySailor", context, steadySailor, y, glucoseLine);
      });           
      
      addBackgroundAndHover(focus, glucoseReads, width, height, x, y, focusCoordinates, chartContainerElement.getBoundingClientRect().left, hoverbox, focusLine);
    });

    }
    
    function addToGraph(focus, className, context, glucoseReads, y, glucoseLineFunc, viewfinderLineFunc) {      

      segments = splitReadsInRangeSegments(glucoseReads);

      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];        
        focus.append("path")
           .attr("class", className + " " + segment.range)
           .attr("clip-path", "url(#clip)")
           .datum(segment.reads)
           .attr("d", glucoseLineFunc);
      }

      if(viewfinderLineFunc != undefined) {
         context.append("path")
           .datum(glucoseReads)
           .attr("d", viewfinderLineFunc);  
      }
         
    }

    function addTargetRangeClip(svg, canvasWidth, canvasHeight, id, lowerBound, upperBound, maxDomainValue, y) {
      svg.append("defs").append("clipPath")
         .attr("id", id)
       .append("rect")
         .attr("width", canvasWidth)
         .attr("height", y(maxDomainValue - upperBound) - y(maxDomainValue - lowerBound))
         .attr("y", y(upperBound));

      svg.append("defs").append("clipPath")
         .attr("id", "clip")
       .append("rect")
         .attr("width", canvasWidth)
         .attr("height", canvasHeight);
    }    

    function addBackgroundAndHover(focus, glucoseReads, width, height, x, y, focusCoordinates, containerLeftPosition, hoverbox, focusLine) {
      // We add a background so that we have a svg area to register the mouse 
      // movement
      var background = focus.append("rect")
            .attr("id", "background")
            .attr("class", "background")            
            .attr("clip-path", "url(#clip)")            
            .attr("width", width)
            .attr("height", height);
        chartBackground = background[0][0];
        chartBackground.addEventListener('mousemove',function(event){
          var rect = this.getBoundingClientRect();        
          var left = event.clientX  - rect.left - this.clientLeft + this.scrollLeft;
          var top = event.clientY - rect.top - this.clientTop + this.scrollTop;

          var time = x.invert(left);        
          coordinates = getHoverCoordinates(glucoseReads, time);
          focusCoordinates[1].x = focusCoordinates[0].x = coordinates.x;
          focus.selectAll("#focusLine").attr("d", focusLine);

          hoverleftposition = event.clientX - containerLeftPosition;
          hoverbox.style("left",  hoverleftposition + "px" );        
          
          hoverbox.text("Glucose " + Math.round(coordinates.y));                         
        }, false);      

        chartBackground.addEventListener('mouseover', function(event) { 
          d3.select(".hoverbox").style("display", "block"); 
          d3.select(".focusLine").style("display", "block"); 
        });          
        chartBackground.addEventListener('mouseout', function(event) { 
          d3.select(".hoverbox").style("display", "none");
          d3.select(".focusLine").style("display", "none");
        } );          

    }

function showDashboard()
    {
        var distribution = null;
        $.getJSON('/{{.PathPrefix}}dashboard', function(data) {

          //hooking up the endpoint to be displayed in the dashboard
          $(".glukitScore").text(data['score']);
          $(".dailyAverage").text(data['median']); //need to change this to average (round existing avg value)
          $(".dailyHigh").text(data['high']);
          $(".dailyLow").text(data['low']);

        }).fail(function() {
          $("div#overlay").removeClass("hidden");
           //blurring the text behind the overlay for effect
          $('.dashboard').addClass("blurryText");
            //noData();
         });
    }
</script>
  <script>
      channel = new goog.appengine.Channel('{{.ChannelToken}}');
      socket = channel.open();
      socket.onopen = function() {
        console.log("connected");
        showDataBrowser();
        showDashboard();
      };
      socket.onmessage = function(message) {
        console.log("onMessage: " + message.data);
        showDataBrowser();
        showDashboard();
      };
      socket.onerror = function() {
        console.log("error");
      };
      socket.onclose = function() {
        console.log("close");
      };
    </script>
      <script>
  document.write('<script src=' +
  ('__proto__' in {} ? 'js/vendor/zepto' : 'js/vendor/jquery') +
  '.js><\/script>')
  </script>

  <script src="js/foundation.min.js"></script>
  <!--

  <script src="js/foundation/foundation.js"></script>

  <script src="js/foundation/foundation.interchange.js"></script>

  <script src="js/foundation/foundation.dropdown.js"></script>

  <script src="js/foundation/foundation.placeholder.js"></script>

  <script src="js/foundation/foundation.forms.js"></script>

  <script src="js/foundation/foundation.alerts.js"></script>

  <script src="js/foundation/foundation.magellan.js"></script>

  <script src="js/foundation/foundation.reveal.js"></script>

  <script src="js/foundation/foundation.tooltips.js"></script>

  <script src="js/foundation/foundation.clearing.js"></script>

  <script src="js/foundation/foundation.cookie.js"></script>

  <script src="js/foundation/foundation.joyride.js"></script>

  <script src="js/foundation/foundation.orbit.js"></script>

  <script src="js/foundation/foundation.section.js"></script>

  <script src="js/foundation/foundation.topbar.js"></script>

  -->

  <script>
    $(document).foundation();
  </script>  
  </body>
</html>
