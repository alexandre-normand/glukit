<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Glukit</title>
    <link rel="stylesheet" href="css/foundation.css" />
    <script src="js/vendor/custom.modernizr.js"></script>
      <link type="text/css" rel="stylesheet" href="css/graph.css">
      <link type="text/css" rel="stylesheet" href="css/detail.css">
      <link type="text/css" rel="stylesheet" href="css/main.css">
      <link type="text/css" rel="stylesheet" href="css/foundation_icons_general/stylesheets/general_foundicons.css">
    	<script src="js/d3.v3.js"></script>
    	<script src="js/jquery-2.0.0.min.js"></script>
      <script type="text/javascript" src="/_ah/channel/jsapi"></script>
      <script src="js/moment-with-langs.min.js"></script>      
      <script src="js/main.js"></script>      
  </head>
  <body class="dataPage">

<div class="sticky">
  <nav class="top-bar dataPage-topbar mainDataPage">
    <ul class="title-area">
    <!-- Title Area -->
      <li class="name">
      <h1><a href="index.html"><img src="images/glukit.png" id="droplet"></a></h1>
      </li>
    <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
      <li class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></li>
  </ul>
  <div class="fixed"></div>
  <section class="top-bar-section">
    <!-- Left Nav Section
    <ul class="left hackwhite">
    </ul>
    -->
    <!-- Right Nav Section -->
    <ul class="right">
    <!--
     <li class="divider"></li>
      <li class="active navlink"><a href="#">How you're doing</a></li>
      <li class="divider "></li>
      <li class="active navlink"><a href="#">Compare</a></li>
      <li class="divider"></li>
      <li class="active navlink"><a href="#">Explore</a></li>
      <li class="divider"></li>
      <li class="divider hide-for-small"></li>
  -->


      <li class="has-form">
        <a class="button" href="index.html" style="color:white !important">Sign out</a>
      </li>

      <!-- <li class="active hackwhite has-dropdown"><img src="img/settings-cog.png"></li> -->
      <li class="divider"></li>
    </ul>
  </section>
</div>
</nav>
</div>

<!-- Overlay if user hasn't imported data yet. NOT YET STYLED - NEED TO FIX! -->
  <div id="overlay" class="hidden">
    <div class="row">
      <div class="large-16 columns">
        <div class="large-3 large-offset-1 columns"> <img src="images/surprisedglukit.png" id="nodataGlukit"></img></div>
        <div class="large-10 columns"><h2>Uh oh! Looks like you havent uploaded any data yet. Let's get you up and running.</h2></div>
      </div>
    </div>
  </div>

<div class="row belowHeader" style="overflow:hidden; padding-top:4px">
    <div class="large-16 columns">
     <div class="row belowHeader" style="overflow:hidden; padding-top:44px">
    <div class="large-16 columns">

      <div class="row dashboard" style="padding-bottom: 0px">
        <div class="large-2 columns">
          <div class="">
            <img src="images/alex-normand.png">
          </div>
        </div>

        <div class="large-6 columns">
            <h1 class="profile"><small class="firstName"></small><small class="lastName"></small></h1><h1 class="profile"></h1>
            <h5 class="profile"><small>Glukit user since Feb 1, 2013</small></h5>
            <br>
            <h3 class="profile"><small>Last sync</small></h3>
            <h5 class="profile"><small class="lastSync"></small></h5>
        </div>
        
        <div class="large-3 columns">
            <div class="circleSlab" id="advanced">
              <div class="insights glukitScore circle" style="padding-top:24%"></div>
            </div>
        </div>
       
        <div class="large-5 columns">
          <div class="">
            <h1 style="padding-top:8%"><small>Glukit Score</small></h1>
            <!-- change this date range to the date range returned -->
            <h5 class="profile"><small>Oct. 14th - Oct 21st</small></h5>
          </div>
        </div>
       
      </div>

      <hr id="features"> 
     


      <div class="row dashboard">
  

<!-- testing -->
<div class="row">
  <div class="small-4 columns"><h3><small>How you're doing</small></h3></div>
</div>
<div class="row">
  <div class="large-16 columns">
    <div class="small-4 columns rangeSelection" id="inRange">
      <h5><i class="foundicon-checkmark">&nbsp; &nbsp;</i>In target range</h5>
    </div>
    <div class="small-4 columns rangeSelection" id="below">
      <h5><i class="foundicon-down-arrow">&nbsp; &nbsp;</i>Below target range</h5>
    </div>
    <div class="small-4 columns rangeSelection" id="above">
      <h5><i class="foundicon-up-arrow">&nbsp; &nbsp;</i>Above target range</h5>
    </div>
  </div>
  <div class="large-16 columns">
    <div class="small-4 columns"><h5></h5></div>
    <div class="small-4 columns rangeSelection" id="inTargetPercentage"><h5></h5></div>
    <div class="small-4 columns rangeSelection"><h5 id="belowTargetPercentage"></h5></div>
    <div class="small-4 columns rangeSelection" id="aboveTargetPercentage"><h5></h5></div>
  </div>

</div>


<!-- hide checkboxes for now 
        <div class="large-3 columns">
          <div class="rangeSlab">
              <label for="checkbox1">
                <input type="checkbox" id="checkbox1" style="display: none;">
                <span class="custom checkbox"></span> Events
              </label>
              <label for="checkbox2">
                <input type="checkbox" id="checkbox2" style="">
                <span class="custom checkbox"></span> Insulin
              </label>
              <label for="checkbox2">
                <input type="checkbox" id="checkbox2" style="">
                <span class="custom checkbox"></span> Food
              </label>
          </div>
        </div>

-->


      </div>
    <hr id="features">
      <div class="row">
        <div class="large-16 columns">
          <div class="slab graph">
            <div id="chart_container">            
              <div id="hoverbox" class="hoverbox"></div>                        
              <div id="y_axis"></div>
              <div id="chart" style="clear: both"></div>              
            </div>
            <div id="slider"></div>            
          </div>
          </div>
        </div>
      </div>
      <div class="row">
        <div class="footer">
          <div class="large-16 columns" style="height:30px">
          </div>
        </div>
      </div>
    </div>
  </div>
<script>
    var TARGET_RANGE_LOWER_BOUND = 63;
    var TARGET_RANGE_UPPER_BOUND = 127;
    // Default to 5 hours 
    var SNAP_DISTANCE_IN_MILLIS = 5 * 2700000;

    var RANGES = {
      HIGH: "HIGH",
      NORMAL: "NORMAL",
      LOW: "LOW"
    }

    function showDataBrowser() {
    var chartNode = document.getElementById("chart");
    chartNode.innerHTML = '';

    var margin = {top: 10, right: 10, bottom: 100, left: 40},
    margin2 = {top: 430, right: 10, bottom: 20, left: 40},
    width = 800 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom,
    viewfinderHeight = 500 - margin2.top - margin2.bottom;

    // Our dates are milliseconds since epoch so that parse function
    // just instantiates a new Date from it.
    var parseDate = function(d) { return new Date(d) };

    // Define the scales
    var x = d3.time.scale().range([0, width]),
    x2 = d3.time.scale().range([0, width]),
    y = d3.scale.linear().range([height, 0]),
    y2 = d3.scale.linear().range([viewfinderHeight, 0]);

    // Define the axes
    var xAxis = d3.svg.axis().scale(x).orient("bottom"),
    xAxis2 = d3.svg.axis().scale(x2).orient("bottom"),
    yAxis = d3.svg.axis().scale(y).orient("left");

    var glucoseLine = d3.svg.line()
      .x(function(d) { return x(d.date); })
      .y(function(d) { return y(d.y); });

    var viewfinderLine = d3.svg.line()
      .x(function(d) { return x2(d.date); })
      .y(function(d) { return y2(d.y); });

    // Find a way to change those as the viewfinder moves
    var userEventArc = d3.svg.arc()
      .innerRadius(2)
      .outerRadius(7)      
      .startAngle(function(d)
           {
            switch (d.type) {
              case "full":                 
                return 0 * Math.PI;
              case "left":                 
                return 1 * Math.PI;
              case "right":                
                return 1 * Math.PI;
             }                      
           
             })
      .endAngle(function(d)
           {
           switch (d.type) {
            case "full": 
              return 2 * Math.PI;
            case "left": 
              return 2 * Math.PI;
            case "right":
              return 0 * Math.PI;
          } });

   var svg = d3.select("#chart").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom);
      
    // That should be the lower bound of the times displayed on the graph
    // driven by the "self" data
    d3.json("/{{.PathPrefix}}data", function(error, data) {
      glucoseReads = data.data[0].data;
      userEvents = data.data[1].data;

      timeRangeLowerBound = glucoseReads[0].x;
      glucoseReads.forEach(function(d) {
        d.date = parseDate(d.x * 1000);
      });
    
      var highestOnChart = d3.max(glucoseReads, function(d) { return d.y; }) + 100;
      x.domain(d3.extent(glucoseReads.map(function(d) { return d.date; })));
      y.domain([0, highestOnChart]);
      x2.domain(x.domain());
      y2.domain(y.domain());

      var focus = svg.append("g")      
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      var context = svg.append("g")
      .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");
     
      focus.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

      focus.append("rect")
            .attr("class", "target_range")
            .attr("clip-path", "url(#rangeClip)")
            .attr("width", width)
            .attr("height", height);

      focus.append("g")
            .attr("class", "y axis")
            .call(yAxis);

      var focusLine = d3.svg.line()
                    .x(function(d) { return x(d.x); })
                    .y(function(d) { return d.y; })
                    .interpolate('linear');

      var focusCoordinates = [];
      focusCoordinates[0] = new Object();
      focusCoordinates[1] = new Object();
      
      focusCoordinates[0].x = 0;
      focusCoordinates[0].y = 0;
      focusCoordinates[1].x = 0;
      focusCoordinates[1].y = height;

      var focusLineElement = focus.append("path")
            .attr("id", "focusLine")
            .attr("class", "focusLine")
            .attr("clip-path", "url(#clip)")
            .datum(focusCoordinates)
            .attr("d", focusLine);

      var hoverbox = d3.select("#hoverbox");   
      var chartContainerElement = d3.select("#chart_container")[0][0];   

      context.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + viewfinderHeight + ")")
            .call(xAxis2);

      addTargetRangeClip(svg, width, height, "rangeClip", TARGET_RANGE_LOWER_BOUND, TARGET_RANGE_UPPER_BOUND, highestOnChart, y);

      nights = getNightsDateRangesForTimeWindow(moment.unix(glucoseReads[0].x).toDate(), moment.unix(glucoseReads[glucoseReads.length - 1].x).toDate());
      // TODO: figure out how this works to display the bar for the nights at the bottom of the graph
      // focus.append("rect")      
      //    .data(nights)
      //    .attr("class", "timeofday night")
      //    .attr("clip-path", "url(#clip)")
      //    .attr("width", function(d) { return 40;})
      //    .attr("height", 5)
      //    .attr("x", function(d) { x(d.start);})
      //    .attr("y", height - 5);

      var segments = splitReadsInRangeSegments(glucoseReads);
      addToGraph(focus, "self", context, segments, glucoseReads, y, glucoseLine, viewfinderLine);    
      window.segments = segments;
      // Trying out the grouping, it doesn't actually use any of this
      userEvents.forEach(function(d) {
        d.date = parseDate(d.x * 1000);
      });
      var userEventGroups = groupEvents(userEvents, 60);

      // The clip path needs to be set on the group of userEvents and NOT on the individual arcs because otherwise,
      // the arcs will get clipped before the transformation and we're never going to be able to get a full circle or 
      // semi-circle
      userEventsSvg = focus.append("g").attr("class", "userEvents").attr("clip-path", "url(#clip)");
      for (var i = 0; i < userEventGroups.length; i++) {
        markers = generateEventMarkers(userEventGroups[i]);
        for (var j = 0; j < markers.length; j++) {          
          userEventsSvg.append("path")
           .attr("class", "event " + markers[j].tag)
           .attr("transform", "translate(" + x(markers[j].date) + "," + y(markers[j].y) + ")")                      
           .datum(markers[j])           
           .attr("d", userEventArc);      
         }        
      }      

      function brushed() {      
        x.domain(brush.empty() ? x2.domain() : brush.extent());        
        focus.selectAll("path.self").attr("d", glucoseLine);
        focus.selectAll("path.steadySailor").attr("d", glucoseLine);         
        focus.selectAll("path.event").attr("transform", function(d) { return "translate(" + x(d.date) + "," + y(d.y) + ")"; });
        focus.select(".x.axis").call(xAxis);        

        extent = brush.extent();
        viewfinderUpperLimit = extent[1];
        viewfinderLowerLimit = extent[0];
        //console.log("limits are " + viewfinderLowerLimit + ", " + viewfinderUpperLimit);
        
        rangeAggregate = getRangeAggregate(segments, viewfinderLowerLimit, viewfinderUpperLimit);
        console.log("Percentage in low: " + rangeAggregate.lowTimeInMinutes / rangeAggregate.getTotalTime() * 100);
        console.log("Percentage in normal: " + rangeAggregate.normalTimeInMinutes / rangeAggregate.getTotalTime() * 100);
        console.log("Percentage in high: " + rangeAggregate.highTimeInMinutes / rangeAggregate.getTotalTime() * 100);
      }

      // snap to days if close enough
      function snapBrush() {      
        if (!d3.event.sourceEvent) return; // only transition after input
        extent = brush.extent();
        viewfinderUpperLimit = extent[1];

        // We iterate from most recent since we assume that most users will look at that data more often        
        for (var i = 0; i < snapGuides.length; i++) {
           snap = snapGuides[i]
           
           diffInMillis = Math.abs(viewfinderUpperLimit - snap);
           if (diffInMillis <= SNAP_DISTANCE_IN_MILLIS) {              
              snapExtent = getDayRangeFromUpperBound(snap.getTime() / 1000);              
              d3.select(this).transition()
                .call(brush.extent(snapExtent))
                .call(brush.event)
                .duration(500)
                .ease("elastic", 15, .25);  
              return;
           }           
        }
      }

      mostRecentReadTimeInSeconds = glucoseReads[glucoseReads.length - 1].x;      
      brushRange = getDayRangeFromUpperBound(mostRecentReadTimeInSeconds);

      // 1 snap every day for 7 days
      var snapGuides = getDateSnapGuides(mostRecentReadTimeInSeconds, 86400, 7);       
      
      var brush = d3.svg.brush()
         .x(x2)        
         .extent(brushRange)
         .on("brush", brushed)
         .on("brushend", snapBrush);
     
      brushElement = context.append("g");
      brushElement.attr("class", "x brush")
          .call(brush)
        .selectAll("rect")
          .attr("y", -6)
          .attr("height", viewfinderHeight + 7);
      
      // Remove resize handles because we don't want to allow resizing. The brush is fixed to the length of one day
      brushElement.selectAll(".resize").remove();
      // Disable cross-hair cursor to avoid user overriding the brush completely
      brushElement.selectAll(".extent").style("pointer-events", "all");
      brushElement.selectAll(".background").style("pointer-events", "none");
      
      // Call a first brushed to view the last day only 
      brushed();

      // Add steady sailor data
      d3.json("/{{.PathPrefix}}steadySailor", function(error, data) {
        if (data != undefined) {
          rawSteadySailor = data.data[0].data;
          
          steadySailor = rawSteadySailor
          if (steadySailor.length > 0) {   
            offset = steadySailor[0].x - timeRangeLowerBound;              
            steadySailor.forEach(function(element) {
              element.x = element.x - offset;          
            });
          }

          steadySailor.forEach(function(d) {    
            d.date = parseDate(d.x * 1000);     
          });

          sailorSegments = splitReadsInRangeSegments(steadySailor);
          addToGraph(focus, "steadySailor", context, sailorSegments, steadySailor, y, glucoseLine);  
        }
        
      });           
      
      addBackgroundAndHover(focus, glucoseReads, userEventGroups, width, height, x, y, focusCoordinates, chartContainerElement, hoverbox, focusLine);
    });

    }
    
    function addToGraph(focus, className, context, segments, glucoseReads, y, glucoseLineFunc, viewfinderLineFunc) {      
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];        
        focus.append("path")
           .attr("class", className + " " + segment.range)
           .attr("clip-path", "url(#clip)")
           .datum(segment.reads)
           .attr("d", glucoseLineFunc);
      }

      if(viewfinderLineFunc != undefined) {
         context.append("path")
           .datum(glucoseReads)
           .attr("d", viewfinderLineFunc);  
      }
         
    }

    function addTargetRangeClip(svg, canvasWidth, canvasHeight, id, lowerBound, upperBound, maxDomainValue, y) {
      svg.append("defs").append("clipPath")
         .attr("id", id)
       .append("rect")
         .attr("width", canvasWidth)
         .attr("height", y(maxDomainValue - upperBound) - y(maxDomainValue - lowerBound))
         .attr("y", y(upperBound));

      svg.append("defs").append("clipPath")
         .attr("id", "clip")
       .append("rect")
         .attr("width", canvasWidth)
         .attr("height", canvasHeight);
    }    

    function addBackgroundAndHover(focus, glucoseReads, userEventGroups, width, height, x, y, focusCoordinates, chartContainerElement, hoverbox, focusLine) {
      // We add a background so that we have a svg area to register the mouse 
      // movement
      var background = focus.append("rect")
            .attr("id", "background")
            .attr("class", "background")            
            .attr("clip-path", "url(#clip)")            
            .attr("width", width)
            .attr("height", height);
        chartBackground = background[0][0];
        chartBackground.addEventListener('mousemove',function(event){
          var rect = this.getBoundingClientRect();        
          var left = event.clientX  - rect.left - this.clientLeft + this.scrollLeft;
          var top = event.clientY - rect.top - this.clientTop + this.scrollTop;

          var time = x.invert(left);        
          
          coordinates = getHoverCoordinates(glucoseReads, time);
          focusCoordinates[1].x = focusCoordinates[0].x = coordinates.x;

          focus.selectAll("#focusLine").attr("d", focusLine);

          hoverleftposition = event.clientX - chartContainerElement.getBoundingClientRect().left;
          hoverbox.style("left",  hoverleftposition + "px" );        
          
          // Clear previous content
          hoverbox.text(null);
          hoverbox.append("p")
            .attr("class", "glucose")
            .text(Math.round(coordinates.y) + " mg/dl");                         
          var userEventGroupIndex = Math.abs(binaryIndexOf.call(userEventGroups, time));                    
          window.hoverbox = hoverbox;
          
          // We beyond the last event group, check if the last is close enough
          if (userEventGroupIndex >= userEventGroups.length) {
            if (isHoveringEventGroup(userEventGroups[userEventGroups.length - 1], time)) {
              userEventGroup = userEventGroups[userEventGroups.length - 1];            
              appendUserEventsToHoverBox(hoverbox, userEventGroup); 
            }           
          }
          // Look for the event after the current position to see if it's close enough
          else if (isHoveringEventGroup(userEventGroups[userEventGroupIndex], time)) {
              userEventGroup = userEventGroups[userEventGroupIndex];            
              appendUserEventsToHoverBox(hoverbox, userEventGroup);            
            } 
          // Look to see if the one prior is close enough
          else if (userEventGroupIndex > 0 && isHoveringEventGroup(userEventGroups[userEventGroupIndex - 1], time)) {
              userEventGroup = userEventGroups[userEventGroupIndex - 1];            
              appendUserEventsToHoverBox(hoverbox, userEventGroup);            
          }
        }, false);      

        chartBackground.addEventListener('mouseover', function(event) { 
          d3.select(".hoverbox").style("display", "block"); 
          d3.select(".focusLine").style("display", "block"); 
        });          
        chartBackground.addEventListener('mouseout', function(event) { 
          d3.select(".hoverbox").style("display", "none");
          d3.select(".focusLine").style("display", "none");
        } );          

    }

function showDashboard()
    {
        var distribution = null;
        $.getJSON('/{{.PathPrefix}}data', function(data) {

          //display user information
          $(".firstName").text(data.firstName);
          $(".lastName").text(data.lastName);
          $(".glukitScore").text(data.score.Value);
          $(".lastSync").text(data.lastSync);
          $(".profilePic").text(data.picture);

        }).fail(function() {
          $("div#overlay").removeClass("hidden");
           //blurring the text behind the overlay for effect
          $('.dashboard').addClass("blurryText");
            //noData();
         });
    }
function highlightLines() {


    $('#inRange').click(function(){
        $('.NORMAL').css("stroke", "red");
        $('.LOW').css("stroke", "grey");
        $('.HIGH').css("stroke", "grey");

        //add a class of 'active' to the element clicked on
        toggleElements();
    });


    $('#below').click(function(){
        $('.NORMAL').css("stroke", "grey");
        $('.LOW').css("stroke", "red");
        $('.HIGH').css("stroke", "grey");

        toggleElements();
    });

    $('#above').click(function(){
        $('.NORMAL').css("stroke", "grey");
        $('.LOW').css("stroke", "grey");
        $('.HIGH').css("stroke", "red");

        toggleElements();
    });


    function toggleElements(){
      //check all of the elements with class rangeX, if it has a class 
    }

  }


</script>
  <script>
      channel = new goog.appengine.Channel('{{.ChannelToken}}');
      socket = channel.open();
      socket.onopen = function() {
        console.log("connected");
        showDataBrowser();
        showDashboard();
        highlightLines();

      };
      socket.onmessage = function(message) {
        console.log("onMessage: " + message.data);
        showDataBrowser();
        showDashboard();
      };
      socket.onerror = function() {
        console.log("error");
      };
      socket.onclose = function() {
        console.log("close");
      };
    </script>
      <script>
  document.write('<script src=' +
  ('__proto__' in {} ? 'js/vendor/zepto' : 'js/vendor/jquery') +
  '.js><\/script>')
  </script>

  <script src="js/foundation.min.js"></script>
  <!--

  <script src="js/foundation/foundation.js"></script>

  <script src="js/foundation/foundation.interchange.js"></script>

  <script src="js/foundation/foundation.dropdown.js"></script>

  <script src="js/foundation/foundation.placeholder.js"></script>

  <script src="js/foundation/foundation.forms.js"></script>

  <script src="js/foundation/foundation.alerts.js"></script>

  <script src="js/foundation/foundation.magellan.js"></script>

  <script src="js/foundation/foundation.reveal.js"></script>

  <script src="js/foundation/foundation.tooltips.js"></script>

  <script src="js/foundation/foundation.clearing.js"></script>

  <script src="js/foundation/foundation.cookie.js"></script>

  <script src="js/foundation/foundation.joyride.js"></script>

  <script src="js/foundation/foundation.orbit.js"></script>

  <script src="js/foundation/foundation.section.js"></script>

  <script src="js/foundation/foundation.topbar.js"></script>

  -->

  <script>
    $(document).foundation();
  </script>  
  </body>
</html>
